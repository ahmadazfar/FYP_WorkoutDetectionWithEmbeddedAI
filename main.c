/*******************************************************************************
* Copyright (C) 2019-2023 Maxim Integrated Products, Inc., All rights Reserved.
*
* This software is protected by copyright laws of the United States and
* of foreign countries. This material may also be protected by patent laws
* and technology transfer regulations of the United States and of foreign
* countries. This software is furnished under a license agreement and/or a
* nondisclosure agreement and may only be used or reproduced in accordance
* with the terms of those agreements. Dissemination of this information to
* any party or parties not specified in the license agreement and/or
* nondisclosure agreement is expressly prohibited.
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
* OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* Except as contained in this notice, the name of Maxim Integrated
* Products, Inc. shall not be used except as stated in the Maxim Integrated
* Products, Inc. Branding Policy.
*
* The mere transfer of this software does not imply any licenses
* of trade secrets, proprietary technology, copyrights, patents,
* trademarks, maskwork rights, or any other form of intellectual
* property whatsoever. Maxim Integrated Products, Inc. retains all
* ownership rights.
*******************************************************************************/

// wd
// This file was @generated by ai8xize.py --test-dir sdk/Examples/MAX78000/CNN --prefix wd --checkpoint-file trained/qat_checkpoint.pth.tar --config-file networks/ai85-autoencoder.yaml --sample-input tests/sample_wd.npy --overwrite --softmax --device MAX78000 --timer 0 --display-checkpoint --verbose

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "sampleoutput.h"
#include "MPU6050test.h"
#include "math.h"
#include "board.h"

#define I2C_MASTER MXC_I2C1
#define I2C_SPEED 100000
#define MPU6050_ADDR  0x68

#define MPU6050_IRQ_PORT MXC_GPIO0
#define MPU6050_IRQ_PIN MXC_GPIO_PIN_19
#define LED_PORT_2    MXC_GPIO2   // Use the appropriate port for your setup
#define LED_PIN_1     MXC_GPIO_PIN_3
#define LED_PIN_2 MXC_GPIO_PIN_4
#define LED_PIN_3 MXC_GPIO_PIN_1
#define LED_PORT_1 MXC_GPIO1


volatile uint32_t cnn_time; // Stopwatch

int16_t x_acc_data[2];
int16_t y_acc_data[2];
int16_t z_acc_data[2];
int16_t x_gyro_data[2];
int16_t y_gyro_data[2];
int16_t z_gyro_data[2];
int16_t x_acc, y_acc, z_acc;
int16_t x_gyro, y_gyro, z_gyro;
float ax, ay, az;

void fail(void)
{
  printf("\n*** FAIL ***\n\n");
  while (1);
}

void delay_ms(int milliseconds) {
    volatile int count;
    while (milliseconds > 0) {
        count = 24000; // Adjust this value based on the clock speed of the microcontroller
        while (count > 0) {
            count--;
        }
        milliseconds--;
    }
}

float calculate_mean(float data[6][200], int start, int count) {
    float sum = 0.0;
        for (int i = start; i < start + count; i++) {
            for (int j = 0; j < 200; j++){
            	sum += data[i][j];
            }
        }

    return sum / count*200;
}

float calculate_std(float data[6][200], int start, int count, float mean) {
    float sum = 0.0;
    for (int i = start; i < start + count; i++) {
    	for(int j = 0;j<200;j++){
		   sum += pow(data[i][j] - mean, 2);
    	}

    }
    return sqrt(sum / count);
}

void normalize(float data[6][200], float normalized_data[6][200]) {
    // Calculate mean and standard deviation for accelerometer data
    float acc_mean = calculate_mean(data, 0, 3);
    float gyro_mean = calculate_mean(data, 3, 3);

    float acc_std = calculate_std(data, 0, 3, acc_mean);
    float gyro_std = calculate_std(data, 3, 3, gyro_mean);




}

void setupLED(void) {
    // Create a GPIO configuration structure for the LED
    mxc_gpio_cfg_t led_cfg_1 = {
        .port = (mxc_gpio_regs_t *) LED_PORT_2,  // Assign the port
        .mask = LED_PIN_1,                       // Assign the pin
        .func = MXC_GPIO_FUNC_OUT,             // Set the function to output
        .pad = MXC_GPIO_PAD_NONE,              // No pull-up or pull-down
        .vssel = MXC_GPIO_VSSEL_VDDIO,         // Set voltage level (depends on your setup)
        .drvstr = MXC_GPIO_DRVSTR_0            // Set drive strength
    };

    mxc_gpio_cfg_t led_cfg_2 = {
        .port = (mxc_gpio_regs_t *) LED_PORT_2,  // Assign the port
        .mask = LED_PIN_2,                       // Assign the pin
        .func = MXC_GPIO_FUNC_OUT,             // Set the function to output
        .pad = MXC_GPIO_PAD_NONE,              // No pull-up or pull-down
        .vssel = MXC_GPIO_VSSEL_VDDIO,         // Set voltage level (depends on your setup)
        .drvstr = MXC_GPIO_DRVSTR_0            // Set drive strength
    };
    mxc_gpio_cfg_t led_cfg_3 = {
        .port = (mxc_gpio_regs_t *) LED_PORT_1,  // Assign the port
        .mask = LED_PIN_3,                       // Assign the pin
        .func = MXC_GPIO_FUNC_OUT,             // Set the function to output
        .pad = MXC_GPIO_PAD_NONE,              // No pull-up or pull-down
        .vssel = MXC_GPIO_VSSEL_VDDIO,         // Set voltage level (depends on your setup)
        .drvstr = MXC_GPIO_DRVSTR_0            // Set drive strength
    };

    MXC_GPIO_Init(LED_PORT_2);
    MXC_GPIO_Init(LED_PORT_1);

    // Configure the GPIO pin for the LED
    MXC_GPIO_Config(&led_cfg_1);
    MXC_GPIO_Config(&led_cfg_2);
    MXC_GPIO_Config(&led_cfg_3);
}

void turnOnLED1(void) {
    // Set the GPIO pin to a high level to turn on the LED
    MXC_GPIO_OutSet((mxc_gpio_regs_t *) LED_PORT_2, LED_PIN_1);
}

void turnOnLED2(void) {
    // Set the GPIO pin to a high level to turn on the LED
    MXC_GPIO_OutSet((mxc_gpio_regs_t *) LED_PORT_2, LED_PIN_2);
}

void turnOnLED3(void) {
    // Set the GPIO pin to a high level to turn on the LED
    MXC_GPIO_OutSet((mxc_gpio_regs_t *) LED_PORT_1, LED_PIN_3);
}

void turnOffLED1(void) {
    // Clear the GPIO pin to a low level to turn off the LED
    MXC_GPIO_OutClr((mxc_gpio_regs_t *) LED_PORT_2, LED_PIN_1);
}

void turnOffLED2(void) {
    // Clear the GPIO pin to a low level to turn off the LED
    MXC_GPIO_OutClr((mxc_gpio_regs_t *) LED_PORT_2, LED_PIN_2);
}

void turnOffLED3(void) {
    // Clear the GPIO pin to a low level to turn off the LED
    MXC_GPIO_OutClr((mxc_gpio_regs_t *) LED_PORT_1, LED_PIN_3);
}
void readMPU6050(float arr[6][200]){

for(int i =0; i<200;i++){
	    	MPU6050_READ_X_ACC(&x_acc_data);
	    	MPU6050_READ_Y_ACC(&y_acc_data);
	    	MPU6050_READ_Z_ACC(&z_acc_data);

	    	MPU6050_READ_X_GYRO(&x_gyro_data);
	    	MPU6050_READ_Y_GYRO(&y_gyro_data);
	    	MPU6050_READ_Z_GYRO(&z_gyro_data);

			x_acc = ((int16_t)x_acc_data[0] << 8) | x_acc_data[1];
			ax = (float)(x_acc - (-512)) / 8192.0;
			y_acc = ((int16_t)y_acc_data[0] << 8) | y_acc_data[1];
			ay = (float)(y_acc - 256) / 8192.0;
			z_acc = ((int16_t)z_acc_data[0] << 8) | z_acc_data[1];
			az = (float)(z_acc - 5120) / 8192.0;


			x_gyro = ((int16_t)x_gyro_data[0] << 8) | x_gyro_data[1];
			y_gyro = ((int16_t)y_gyro_data[0] << 8) | y_gyro_data[1];
			z_gyro = ((int16_t)z_gyro_data[0] << 8) | z_gyro_data[1];

			float rate_roll = (x_gyro +256)/131;
			float rate_pitch = (y_gyro + 256) / 131;
			float rate_yaw = (z_gyro -3328)/ 131 ;


			printf("[x: %.2f, y: %.2f, z: %.2f]", ax,  ay, az);
			printf("[x: %.6f, y: %.6f, z: %.6f]", rate_roll, rate_pitch, rate_yaw);
			printf("\n");

			//fprintf(fptr,"%.2f, %.2f, %.2f,%.2f, %.2f, %.2f", ax, ay, az, rate_roll, rate_pitch, rate_yaw);

			arr[0][i] = ((int)(ax * 100 + 0.5)) / 100.0;
			arr[1][i] = ((int)(ay * 100 + 0.5)) / 100.0;
			arr[2][i] = ((int)(az * 100 + 0.5)) / 100.0;
			arr[3][i] = ((int)(rate_roll * 1000000 + 0.5)) / 1000000.0;
			arr[4][i] = ((int)(rate_pitch * 1000000 + 0.5)) / 1000000.0;
			arr[5][i] = ((int)(rate_yaw * 1000000 + 0.5)) / 1000000.0;



			delay_ms(25);



		/*	x_acc = ((int16_t)x_acc_data[0] << 8) | x_acc_data[1];
			ax = (float) (x_acc - (6400-4096)) / 4096.0 +0.5;
			y_acc = ((int16_t)y_acc_data[0] << 8) | y_acc_data[1];
			ay = (float) (y_acc -(6144-4096))/ 4096.0 + 0.56;
			z_acc = ((int16_t)z_acc_data[0] << 8) | z_acc_data[1];
			az = (float) (z_acc - (3840 - 4096))/4096.0  - 0.69 - 1.62;


			x_gyro = ((int16_t)x_gyro_data[0] << 8) | x_gyro_data[1];
			y_gyro = ((int16_t)y_gyro_data[0] << 8) | y_gyro_data[1];
			z_gyro = ((int16_t)z_gyro_data[0] << 8) | z_gyro_data[1];

			float rate_roll = x_gyro/65.5 - 19.541985 + 23.450382;
			float rate_pitch = y_gyro/65.5 + 27.358778 -  23.450380;
			float rate_yaw = z_gyro/65.5 + 3.908397 - 27.358780 - 27;


			printf("[x: %.2f, y: %.2f, z: %.2f]", ax,  ay, az);
			printf("[x: %.6f, y: %.6f, z: %.6f]", rate_roll, rate_pitch, rate_yaw);
			printf("\n");

			//fprintf(fptr,"%.2f, %.2f, %.2f,%.2f, %.2f, %.2f", ax, ay, az, rate_roll, rate_pitch, rate_yaw);

			arr[0][i] = ax;
			arr[1][i] = ay;
			arr[2][i] = az;
			arr[3][i] = rate_roll;
			arr[4][i] = rate_pitch;
			arr[5][i] = rate_yaw;



			delay_ms(25);*/



}
}

// 6-channel 200x1 data input (1200 bytes total / 200 bytes per channel):
// HWC 200x1, channels 0 to 3


void load_input(float input[6][200])
{
  // This function loads the sample data input -- replace with actual


  memcpy32((uint32_t *) 0x50400000, input[0], 200);
  memcpy32((uint32_t *) 0x50400100, input[1], 200);
  memcpy32((uint32_t *) 0x50400200, input[2], 200);
  memcpy32((uint32_t *) 0x50400300, input[3], 200);
  memcpy32((uint32_t *) 0x50400400, input[4], 200);
  memcpy32((uint32_t *) 0x50400500, input[5], 200);

}

// Expected output of layer 3 for wd given the sample input (known-answer test)
// Delete this function for production code
static const uint32_t sample_output[] = SAMPLE_OUTPUT;
int check_output(void)
{
  int i;
  uint32_t mask, len;
  volatile uint32_t *addr;
  const uint32_t *ptr = sample_output;

  while ((addr = (volatile uint32_t *) *ptr++) != 0) {
    mask = *ptr++;
    len = *ptr++;
    for (i = 0; i < len; i++)
      if ((*addr++ & mask) != *ptr++) {
        printf("Data mismatch (%d/%d) at address 0x%08x: Expected 0x%08x, read 0x%08x.\n",
               i + 1, len, addr - 1, *(ptr - 1), *(addr - 1) & mask);
        return CNN_FAIL;
      }
  }

  return CNN_OK;
}

// Classification layer:
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

void softmax_layer(void)
{
  cnn_unload((uint32_t *) ml_data);
  softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

int main(void)
{
  int i;
  int digs, tens;
  float input_data[200][6];
  float normalized_data[6][200];

  turnOffLED1();
  turnOffLED2();
  turnOffLED3();

  MXC_ICC_Enable(MXC_ICC0); // Enable cache

  // Switch to 100 MHz clock
  MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
  SystemCoreClockUpdate();

  printf("Waiting...\n");
  turnOnLED1();
  turnOnLED2();
  turnOnLED3();

  // DO NOT DELETE THIS LINE:
  MXC_Delay(SEC(2)); // Let debugger interrupt if needed

  setbuf(stdout, NULL);

	if (MXC_I2C_Init(I2C_MASTER, 1, MPU6050_ADDR << 1) != E_NO_ERROR) {
		printf("Trouble initializing I2C instance.");
	}
	else{
		printf("I2C Instance initialized\n");
	}

  	MXC_I2C_SetFrequency(I2C_MASTER, I2C_SPEED);
  	setupLED();
  	MPU6050_initialize();

  	readMPU6050(input_data);

	normalize(input_data, normalized_data);


  // Enable peripheral, enable CNN interrupt, turn on CNN clock
  // CNN clock: APB (50 MHz) div 1
  cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);
/*
  for(int i = 0; i < 6; i++) {
          for (int j = 0; j < 200; j++) {
              printf("%.3f ", normalized_data[i][j]);
          }

          printf("\n");
      }*/


  printf("\n*** CNN Inference Test wd ***\n");

  cnn_init(); // Bring state machine into consistent state
  cnn_load_weights(); // Load kernels
  cnn_load_bias();
  cnn_configure(); // Configure state machine
  load_input(input_data); // Load data input
  cnn_start(); // Start CNN processing

  while (cnn_time == 0)
    MXC_LP_EnterSleepMode(); // Wait for CNN

  //if (check_output() != CNN_OK) fail();
  softmax_layer();

  printf("\n*** PASS ***\n\n");

#ifdef CNN_INFERENCE_TIMER
  printf("Approximate inference time: %u us\n\n", cnn_time);
#endif

  cnn_disable(); // Shut down CNN clock, disable peripheral

  printf("Classification results:\n");
  int highest_class = -1;
  int highest_value = -1;
  for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
    digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
    tens = digs % 10;
    digs = digs / 10;

    printf("[%7d] -> Class %d: %d.%d%%\n", ml_data[i], i, digs, tens);
    if (ml_softmax[i] > highest_value) {
               highest_value = ml_softmax[i];
               highest_class = i;
                          }
  }
  turnOffLED1();
  turnOffLED2();
  turnOffLED3();
  delay_ms(500);
  printf("highest class: %d\n", highest_class);

  if (highest_class != -1) {
      switch(highest_class){
      case 0:
    	  turnOnLED1();
    	  break;
      case 1:
      	  turnOnLED2();
      	  break;
	 case 2:
	 	  turnOnLED3();
	 	  break;
	  }
  }



  return 0;
}
/*
  SUMMARY OF OPS
  Hardware: 1,504,800 ops (1,485,000 macc; 19,800 comp; 0 add; 0 mul; 0 bitwise)
    Layer 0: 120,384 ops (114,048 macc; 6,336 comp; 0 add; 0 mul; 0 bitwise)
    Layer 1: 1,229,184 ops (1,216,512 macc; 12,672 comp; 0 add; 0 mul; 0 bitwise)
    Layer 2: 152,856 ops (152,064 macc; 792 comp; 0 add; 0 mul; 0 bitwise)
    Layer 3: 2,376 ops (2,376 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

  RESOURCE USAGE
  Weight memory: 9,864 bytes out of 442,368 bytes total (2.2%)
  Bias memory:   103 bytes out of 2,048 bytes total (5.0%)
*/

